/**
 * Orchestrator - Chains all generators together
 * 
 * Pipeline:
 * 1. BriefGenerator ‚Üí product-brief.md (AI-powered)
 * 2. InspirationEngine ‚Üí 0.design-moodboard.md
 * 3. SpecGenerator ‚Üí STYLE_GUIDE.md + section specs
 * 4. SiteGenerator ‚Üí Next.js components
 * 5. DeployService ‚Üí Vercel deployment
 */

require('dotenv').config();
const path = require('path');
const fs = require('fs');
const { execSync } = require('child_process');
const OpenAI = require('openai');
const { runInspirationEngine } = require('./inspiration_engine');
const { generateStyleGuide, generateProjectRequirements, generateSectionSpecs } = require('./spec_generator');
const { generateSite } = require('./site_generator');
const { deployToVercel } = require('./deploy_service');
const { parseBrief } = require('./brief_parser');

// Initialize OpenRouter client
const openai = new OpenAI({
    baseURL: 'https://openrouter.ai/api/v1',
    apiKey: process.env.OPENROUTER_API_KEY
});

// Use Flash model for brief generation (cheaper for text-only tasks)
const GEMINI_MODEL = process.env.GEMINI_MODEL_FAST || 'google/gemini-3-flash-preview';

// Job status tracking
const jobStatuses = new Map();

/**
 * Update job status
 */
function updateJob(job, updates) {
    Object.assign(job, updates);
    console.log(`üìä Job ${job.id}: ${job.status}`);
}

/**
 * AI-Powered Product Brief Generator
 * 
 * Priority:
 * 1. Use pre-generated brief from n8n (input.briefContent)
 * 2. Generate with AI if no pre-generated brief
 * 3. Fallback to template if AI fails
 */
async function generateBrief(input, outputDir) {
    const briefPath = path.join(outputDir, 'product-brief.md');

    // Check if brief was pre-generated by n8n AI Agent
    if (input.briefContent) {
        console.log('üìÑ Using pre-generated brief from n8n...');
        fs.writeFileSync(briefPath, input.briefContent);
        console.log(`‚úÖ Saved: product-brief.md (from n8n)`);
        return briefPath;
    }

    // Otherwise, generate with AI
    console.log('ü§ñ Generating brief with AI...');

    const prompt = `You are a professional content strategist. Transform the following raw user input from a form into a polished, well-structured Product Brief for a portfolio website.

## Raw User Input:
- **Full Name:** ${input.name || 'Not provided'}
- **Role/Title:** ${input.role || 'Not provided'}
- **Years of Experience:** ${input.experience || 'Not provided'}
- **Tagline:** ${input.tagline || 'Not provided'}
- **About/Bio:** ${input.about || 'Not provided'}
- **Visual Style Preference:** ${input.vibe || 'Not provided'}
- **Avatar Image URL:** ${input.avatar || 'Not provided'}
- **Social Links:** ${input.socialLinks || 'Not provided'}
- **Email:** ${input.email || 'Not provided'}
- **Number of Projects:** ${input.projectCount || 'Not provided'}
- **Projects/Clients (raw):** ${input.projects || 'Not provided'}
- **Project Links (raw):** ${input.projectLinks || 'Not provided'}
- **Project Impact (raw):** ${input.projectImpact || 'Not provided'}
- **Testimonials:** ${input.testimonials || 'Not provided'}

## Your Task:
Create a comprehensive Product Brief in markdown format with these sections:

1. **Client Overview** - Name, role, experience, and a refined tagline
2. **Professional Summary** - A polished version of their bio (expand if too short, refine if messy)
3. **Design Direction** - Their visual style preference, interpreted for web design
4. **Projects Portfolio** - Parse the raw project text and structure each project with:
   - Project/Client Name
   - Role
   - Link (if provided)
   - Impact/Contribution
5. **Contact Information** - Email and social links, properly formatted
6. **Testimonials** - Format any testimonials provided (if none, omit this section)

## Rules:
- Be professional but personable
- If information is missing, make reasonable assumptions based on context
- Structure the projects cleanly even if the input is messy (e.g., "Monad - Community Manager" should become a proper project entry)
- Extract links from the project links field and match them to projects
- Keep the user's voice but polish the grammar and clarity

Output ONLY the markdown content, no explanations.`;

    try {
        const response = await openai.chat.completions.create({
            model: GEMINI_MODEL,
            messages: [
                { role: 'system', content: 'You are an expert at creating professional portfolio briefs. Output clean markdown only.' },
                { role: 'user', content: prompt }
            ],
            temperature: 0.7,
            max_tokens: 2000
        });

        const briefContent = response.choices[0].message.content;

        // Add header
        const finalBrief = `# Product Brief
*AI-Generated from user input*

${briefContent}
`;

        const briefPath = path.join(outputDir, 'product-brief.md');
        fs.writeFileSync(briefPath, finalBrief);
        console.log(`‚úÖ Generated: product-brief.md (AI-structured)`);
        return briefPath;

    } catch (error) {
        console.error('‚ö†Ô∏è AI brief generation failed, using template fallback:', error.message);
        return generateBriefFallback(input, outputDir);
    }
}

/**
 * Fallback: Template-based brief (if AI fails)
 */
function generateBriefFallback(input, outputDir) {
    const brief = `# Product Brief

## Client Information
- **Name:** ${input.name}
- **Role:** ${input.role}
- **Experience:** ${input.experience || 'Not specified'} years
- **Tagline:** ${input.tagline || `${input.role} & Creative Professional`}

## Design Direction
- **Vibe:** ${input.vibe}

## About
${input.about || `${input.name} is a passionate ${input.role?.toLowerCase() || 'professional'} dedicated to creating exceptional work.`}

## Projects
${input.projects || '*Projects to be detailed*'}

## Project Links
${input.projectLinks || '*Links to be added*'}

## Impact
${input.projectImpact || '*Impact details to be added*'}

## Contact
- Email: ${input.email || 'Not provided'}
- Social: ${input.socialLinks || 'Not provided'}

## Testimonials
${input.testimonials || '*No testimonials provided*'}
`;

    const briefPath = path.join(outputDir, 'product-brief.md');
    fs.writeFileSync(briefPath, brief);
    console.log(`‚úÖ Generated: product-brief.md (template fallback)`);
    return briefPath;
}

/**
 * Main Pipeline Runner
 */
async function runPipeline(job) {
    const startTime = Date.now();

    try {
        updateJob(job, { status: 'running' });

        const projectRoot = path.join(__dirname, '..');
        const guidelinesDir = path.join(projectRoot, 'website-guidelines');
        const sectionsDir = path.join(projectRoot, 'website-sections');
        const outputDir = path.join(projectRoot, 'output');

        // Ensure directories exist
        [guidelinesDir, sectionsDir, outputDir].forEach(dir => {
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
            }
        });

        // Step 1: Generate Brief
        console.log('\nüìù Step 1/5: Generating Brief...');
        updateJob(job, { status: 'generating_brief' });
        generateBrief(job.input, guidelinesDir);

        // Step 2: Run Inspiration Engine
        console.log('\nüé® Step 2/5: Running Inspiration Engine...');
        updateJob(job, { status: 'generating_inspiration' });

        // Parse brief to get searchVibe (pre-generated by n8n)
        const briefPath = path.join(guidelinesDir, 'product-brief.md');
        const briefData = parseBrief(briefPath);
        const searchVibe = briefData.designDirection?.searchVibe || job.input.vibe;
        console.log(`   üîç Using search vibe: "${searchVibe}"`);
        await runInspirationEngine(searchVibe);

        // Step 3: Generate Specs
        console.log('\nüìã Step 3/5: Generating Style Guide & Specs...');
        updateJob(job, { status: 'generating_specs' });

        const moodboardPath = path.join(guidelinesDir, '0.design-moodboard.md');

        // Generate STYLE_GUIDE.md
        await generateStyleGuide(briefPath, moodboardPath);

        // Generate PROJECT_REQUIREMENTS.md
        const styleGuidePath = path.join(guidelinesDir, 'STYLE_GUIDE.md');
        await generateProjectRequirements(briefPath, styleGuidePath);

        // Generate section specs
        await generateSectionSpecs(briefPath, styleGuidePath);

        // Step 4: Generate Site
        console.log('\nüèóÔ∏è Step 4/5: Generating Next.js Site...');
        updateJob(job, { status: 'generating_site' });
        await generateSite();

        // Step 4.5: Verify Build Locally (catch errors before Vercel deployment)
        console.log('\nüîç Step 4.5: Verifying Build Locally...');
        updateJob(job, { status: 'verifying_build' });

        try {
            console.log('   üì¶ Installing dependencies...');
            execSync('npm install', { cwd: outputDir, stdio: 'pipe' });

            console.log('   üî® Running production build...');
            execSync('npm run build', { cwd: outputDir, stdio: 'pipe' });

            console.log('   ‚úÖ Build verification passed!');
        } catch (buildError) {
            const errorOutput = buildError.stderr?.toString() || buildError.stdout?.toString() || buildError.message;
            console.error('   ‚ùå Build verification failed!');
            console.error('   üìã Error details:');
            console.error(errorOutput.split('\n').slice(-20).join('\n')); // Last 20 lines of error

            updateJob(job, {
                status: 'build_failed',
                error: 'Build verification failed: ' + errorOutput.substring(0, 500)
            });

            throw new Error('Build verification failed. Check logs for TypeScript errors.');
        }

        // Step 5: Deploy to Vercel
        console.log('\nüöÄ Step 5/5: Deploying to Vercel...');
        updateJob(job, { status: 'deploying' });

        const deployResult = await deployToVercel({
            projectName: `portfolio-${job.input.name.toLowerCase().replace(/\s+/g, '-')}`,
            outputDir: outputDir
        });

        // Complete
        const duration = ((Date.now() - startTime) / 1000).toFixed(1);
        updateJob(job, {
            status: 'complete',
            outputPath: outputDir,
            deployUrl: deployResult.url,
            duration: `${duration}s`
        });

        console.log(`\n${'='.repeat(60)}`);
        console.log(`üéâ Pipeline Complete!`);
        console.log(`   Duration: ${duration}s`);
        console.log(`   Deploy URL: ${deployResult.url}`);
        console.log(`${'='.repeat(60)}\n`);

        return job;

    } catch (error) {
        console.error('‚ùå Pipeline Error:', error);
        updateJob(job, {
            status: 'failed',
            error: error.message
        });
        throw error;
    }
}

/**
 * Get job status
 */
function getJobStatus(jobId) {
    return jobStatuses.get(jobId) || null;
}

// CLI Support
if (require.main === module) {
    const projectRoot = path.join(__dirname, '..');
    const guidelinesDir = path.join(projectRoot, 'website-guidelines');
    const briefPath = path.join(guidelinesDir, 'product-brief.md');

    // Check if a real brief exists
    let briefContent = null;
    let clientName = 'Test User';
    let clientVibe = 'Minimalist Dark Portfolio';

    if (fs.existsSync(briefPath)) {
        console.log('üìÑ Found existing product-brief.md, using real data...');
        briefContent = fs.readFileSync(briefPath, 'utf8');

        // Extract name and vibe from the brief
        const nameMatch = briefContent.match(/\*\*Name:\*\*\s*(.+)/);
        const vibeMatch = briefContent.match(/\*\*Search Vibe:\*\*\s*(.+)/) ||
            briefContent.match(/\*\*Visual Style:\*\*\s*(.+)/);

        if (nameMatch) clientName = nameMatch[1].trim();
        if (vibeMatch) clientVibe = vibeMatch[1].trim();

        console.log(`   üìã Client: ${clientName}`);
        console.log(`   üé® Vibe: ${clientVibe}`);
    } else {
        console.log('‚ö†Ô∏è No product-brief.md found, using fallback test data...');
        briefContent = `# Product Brief

## Client Overview
- **Name:** Test User
- **Title:** Professional
- **Experience:** 5 years

## Professional Summary
A passionate professional dedicated to creating exceptional work.

## Projects Portfolio
### Sample Project
- **Role:** Lead
- **Impact:** Created value

## Contact Information
- **Email:** test@example.com
`;
    }

    const testJob = {
        id: 'test-' + Date.now(),
        input: {
            name: clientName,
            vibe: clientVibe,
            briefContent: briefContent
        }
    };

    runPipeline(testJob).then(() => {
        console.log('‚úÖ Test pipeline complete');
    }).catch(err => {
        console.error('‚ùå Test pipeline failed:', err);
        process.exit(1);
    });
}

module.exports = { runPipeline, getJobStatus };
